<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>environment API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>environment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
import time
import turtle
import math
import random
from typing import Any

from dataclasses import dataclass
import numpy as np
from numpy.random import randint, seed
import ipdb

colors = [&#39;Red&#39;, &#39;Black&#39;, &#39;Orange&#39;, &#39;Pink&#39;, &#39;Green&#39;, &#39;Brown&#39;, &#39;Purple&#39;]

@dataclass
class Observation:
    state: Any
    nextState: Any
    reward: float
    action: float
    done: bool


def distance(a, b):
    &#34;&#34;&#34;
    Computes a
    :param a:
    :param b:
    :return:
    &#34;&#34;&#34;
    x = a[0] - b[0]
    y = a[1] - b[1]
    return math.sqrt(x ** 2 + y ** 2)

def random_color():
    rgbl=[255,0,0]
    random.shuffle(rgbl)
    return (rgbl)

class section:

    def __init__(self, sectionLen, maxSectionLen):
        &#34;&#34;&#34;
        Section class represents a single section of a continuum robot

        :param sectionLen: Minimum section length\n
        :param maxSectionLen: Maximum Section length
        &#34;&#34;&#34;

        self.baseLocation = [0, 0]
        self.baseAngle = 0
        self.transformations = []
        # Set of baseLocations and Angles

        self.section = None
        self.render = False
        self.baseFrame = self.endFrame = None
        self.curve = None


        self.sectionLen = sectionLen
        self.minSectionLen = sectionLen
        self.maxSectionLen = sectionLen +  maxSectionLen

        self.zero = 0.00001
        self.leftLimit = 1.8 * math.pi
        self.currentAngle = self.zero
        self.tipPos = (0, 0)

        self.controls = {
            &#39;l&#39;: self.stepLeft,
            &#39;r&#39;: self.stepRight,
            &#39;e&#39;: self.extendArm,
            &#39;c&#39;: self.contractArm
        }
        self.controlNum = {
            &#39;l&#39;: 0, &#39;r&#39;: 1, &#39;e&#39;: 2, &#39;c&#39;: 3
        }

    def setBaseLocation(self, x, y):
        &#39;&#39;&#39;
        setBaseLocation is used modify the starting position of
        the section.
        :param x: x coordinate of the new base position
        :param y: y coordinate of the new base position
        :return: None
        &#39;&#39;&#39;
        self.baseLocation = [x, y]

    def setRender(self, state):
        &#39;&#39;&#39;
        setRender Method is used enable/disable rendering
        :param state: bool
        :return: None
        &#39;&#39;&#39;
        self.render = state

    def stepLeft(self):
        &#34;&#34;&#34;
        stepLeft function will increase the curvature angle towards 2π
        while the section Length will remain the same. Each step will
        increase the angle by 0.01
        :return: None
        &#34;&#34;&#34;
        # increase by angle by .5 degree
        if self.currentAngle == self.zero:
            self.currentAngle = 0

        self.currentAngle += 0.01
        if self.currentAngle &gt;= self.leftLimit:
            self.currentAngle -= 0.01
            # print(&#34;Left angle limit reached&#34;, self.currentAngle)
            return False

        if self.render:
            self.drawSection(self.currentAngle)

        return True

    def stepRight(self):
        &#34;&#34;&#34;
        stepRight function will decrease the curvature angle towards -2π
        while the section Length will remain the same. Each step will
        decrease the angle by 0.01
        :return: None
        &#34;&#34;&#34;
        # decrease by angle by .5 degree
        if self.currentAngle == self.zero:
            self.currentAngle = 0

        self.currentAngle -= 0.01
        if self.currentAngle &lt;= -self.leftLimit:
            self.currentAngle += 0.01
            # print(&#34;Right angle limit reached&#34;, self.currentAngle)
            return False
        if self.render:
            self.drawSection(self.currentAngle)

        return True

    def extendArm(self):
        &#34;&#34;&#34;
        extendArm will increase the length of section by a single unit
        if the length is below the maximum increase. Curvature will remain
        constant
        :return: None
        &#34;&#34;&#34;

        if self.sectionLen == self.maxSectionLen:
            assert &#34;Section max length has reached&#34;
            return True
        else:
            self.sectionLen += 1
        if self.render:
            self.drawSection(self.currentAngle)
            self.displayCurve()
        return True

    def contractArm(self):
        &#34;&#34;&#34;
        contractArm will decrease the length of section by a single unit
        if the length is above the minimum length. Curvature will remain
        constant
        :return: None
        &#34;&#34;&#34;
        if self.sectionLen == self.minSectionLen:
            assert &#34;Section min length has reached&#34;
            return True
        else:
            self.sectionLen -= 1

        if self.render:
            self.drawSection(self.currentAngle)
            self.displayCurve()

        return True

    def drawSection(self, transformations):
        &#34;&#34;&#34;
        drawSection will draw the current representation of the section
        based on the given angle and current section length
        :param angle: Angle of the curvature. Should not be used
        :return: None
        &#34;&#34;&#34;
        self.section.clear()
        self.section.hideturtle()
        self.section.up()
        self.section.setpos(self.baseLocation[0], self.baseLocation[1])

        angle = self.currentAngle
        if angle == 0:  # Use epsilon difference
            angle = self.zero

        radius = self.sectionLen / angle  # curvature is 0 ==&gt; radius is infinite

        t = np.linspace(0, angle, self.sectionLen)
        x = radius * np.cos(t)
        y = radius * np.sin(t)

        allPoints = np.vstack((x, y)).T
        allPoints[:,0] = allPoints[:,0] - radius


        # print(&#34;\t First Point&#34;, allPoints[0])
        # print(&#34;\t Base Location:&#34;, self.baseLocation)

        for i in range(len(transformations)):
            baseAngle = transformations[i]
            r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                          (np.sin(baseAngle), np.cos(baseAngle))))
            allPoints = np.dot(r, allPoints.T).T

        allPoints[:,0] = allPoints[:,0] + self.baseLocation[0]
        allPoints[:, 1] = allPoints[:, 1] + self.baseLocation[1]

        disk = 1
        for n in range(self.sectionLen):
            px = allPoints[n][0]
            py = allPoints[n][1]

            # if n == 0 or n == self.sectionLen - 1:
            #     print(&#39;\tPoint=&#39; + str(n) + &#39; :&#39;, px, py)

            self.section.down()
            self.section.setpos(px, py)
            if disk % 10 == 0:
               self.section.dot(2)

            disk = disk % 10 + 1
            self.section.up()

        # self.tipPos = (x[len(x) - 1] - radius, y[len(y) - 1])
        self.section.home()

    def getTipPos(self, transformations):
        &#34;&#34;&#34;
        getTipPos return a (x,y) coordinate of where the tip of the section is located
        :return: float
        &#34;&#34;&#34;
        angle = self.currentAngle
        if angle == 0:  # Use epsilon difference
            angle = self.zero

        radius = self.sectionLen / angle  # curvature is 0 ==&gt; radius is infinite

        t = np.linspace(0, angle, self.sectionLen)
        x = radius * np.cos(t)
        y = radius * np.sin(t)

        allPoints = np.vstack((x, y)).T
        allPoints[:, 0] = allPoints[:, 0] - radius

        for i in range(len(transformations)):
            baseAngle = transformations[i]
            r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                          (np.sin(baseAngle), np.cos(baseAngle))))
            allPoints = np.dot(r, allPoints.T).T

        allPoints[:, 0] = allPoints[:, 0] + self.baseLocation[0]
        allPoints[:, 1] = allPoints[:, 1] + self.baseLocation[1]

        px = allPoints[-1][0]
        py = allPoints[-1][1]

        point = [px, py]

        return point

    def displayCurve(self, transformations):
        &#34;&#34;&#34;
        displayCurve is used of visualize all the positions that the
        section can be configured to based on its current section length
        :return: None
        &#34;&#34;&#34;
        tool = self.curve
        tool.clear()
        tool.hideturtle()
        tool.up()

        ang = np.linspace(-2 * math.pi, 2 * math.pi, 500)

        for i in range(len(ang)):
            angle = ang[i]
            radius = self.sectionLen / angle

            t = np.linspace(0, angle, self.sectionLen)
            x = radius * np.cos(t)
            y = radius * np.sin(t)

            x = x[-1]
            y = y[-1]

            x = x - radius
            points = [x,y]
            for i in range(len(transformations)):
                baseAngle = transformations[i]
                r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                              (np.sin(baseAngle), np.cos(baseAngle))))
                points = np.dot(r, points)

            points[0] = points[0] + self.baseLocation[0]
            points[1] = points[1] + self.baseLocation[1]

            self.curve.goto(points[0], points[1])
            self.curve.dot(2, &#39;green&#39;)
            self.curve.up()


class Robot:
    def __init__(self):
        &#39;&#39;&#39;
        Robot class is a super class, which can be used to
        make a series of sections to work together.
        &#39;&#39;&#39;
        self.sections = []
        self.zero = 0.00001
        self.tipPosition = 0
        self.controlNum = {
            &#39;l&#39;: 0, &#39;r&#39;: 1, &#39;e&#39;: 2, &#39;c&#39;: 3
        }
        self.controls = [&#39;l&#39;,&#39;r&#39;,&#39;e&#39;,&#39;c&#39;]
        self.actions = []
        self.eRender = False

    def newSection(self):
        &#39;&#39;&#39;
        newSection creates a new section and adds it to the end of
        the robot. Default section is 100
        :return: None
        &#39;&#39;&#39;
        newSection = section(100, 20)
        angles = self.getAllCurrentAngles()
        if len(self.sections) &gt;= 1:
            newTip = self.sections[-1].getTipPos(angles)
            newSection.setBaseLocation(newTip[0], newTip[1])

        # if self.eRender:
        #     turtle.Screen().colormode(255)
        #     color = tuple(np.random.choice(range(255), size=3))
        #     newSection.section.color(color[0], color[1], color[2])

        self.sections.append(newSection)
        self.genActionSet()

    def getAllCurrentAngles(self):
        &#39;&#39;&#39;
        getAllCurrentAngles gets the curvature angle for each section
        :return: list[float]
        &#39;&#39;&#39;
        angles = []
        for i in range(len(self.sections)):
            angle = self.sections[i].currentAngle
            # if angle != self.zero:
            angles.append(angle)

        return angles

    def getAllSectionConfigurations(self):
        &#34;&#34;&#34;
        getAllSectionConfigurations is used to get the current curvature and length of
        each section of the robot
        :return:
        &#34;&#34;&#34;
        angles = self.getAllCurrentAngles()
        configs = []
        for i in range(len(self.sections)):
            angle = angles[i]
            secLen = self.sections[i].sectionLen
            config = (angle, secLen)
            configs.extend(config)

        return configs

    def step(self, secNum, action):
        &#39;&#39;&#39;
        step methods will conduct the given action for the given section
        :param secNum: Section number in the robot (index starting at 1)
        :param action: action (l,r,c,e)
        :return:  None
        &#39;&#39;&#39;
        secNum -= 1
        # # Base Section

        stepLimitReached = self.sections[secNum].controls[action]()

        angles = self.getAllCurrentAngles()

        tipPos = self.sections[secNum].getTipPos(angles[:secNum])
        i = secNum + 1
        while i &lt; len(self.sections):

            self.sections[i].setBaseLocation(tipPos[0], tipPos[1])

            tipPos = self.sections[i].getTipPos(angles[:i])
            i += 1

        return stepLimitReached

    def endEffectorPos(self):
        &#34;&#34;&#34;
        endEffectorPos is used to determine where tip position of the robot is currently
        :return: tuple of coordinates
        &#34;&#34;&#34;
        lastSection = self.sections[len(self.sections) - 1]
        transformations = self.getAllCurrentAngles()
        tipPos = lastSection.getTipPos(transformations[:len(self.sections) - 1])

        return tipPos

    def randomAction(self):
        &#34;&#34;&#34;
        randomAction picks a random action to take for the robot
        :return:
        &#34;&#34;&#34;
        action = randint(0, len(self.actions))
        return self.actions[action]

    def reset(self):
        &#34;&#34;&#34;
        reset, will delete the old robot sections and generate a robot with the same
        number of sections
        :return: None
        &#34;&#34;&#34;
        currentSecs = len(self.sections)
        self.sections = []
        for i in range(currentSecs):
            self.newSection()

    def render(self):
        &#39;&#39;&#39;
        render will draw out each section
        :return:
        &#39;&#39;&#39;
        angles = self.getAllCurrentAngles()
        for i in range(len(self.sections)):
            # print(&#34;--------- Section &#34; + str(i) + &#39;-----------&#39;)
            sec = self.sections[i]
            transformations = angles[:i]
            # print(&#39;\t transformations:&#39;, transformations)
            sec.drawSection(transformations)
            # sec.displayCurve(transformations)
            # sec.displayCurve(transformations)

    def buildRenderComponents(self):
        &#34;&#34;&#34;
        buildRenderComponents is used to assign turtle tools to components
        that are required to draw out the entire robot
        :return: Nones
        &#34;&#34;&#34;
        for i in range(len(self.sections)):
            sec = self.sections[i]
            sec.section = turtle.Turtle()
            sec.section.width(2)
            sec.section.hideturtle()
            # color = tuple(np.random.choice(range(255), size=3))
            color = colors[random.randint(0, len(colors)-1)]
            # sec.section.color(color[0], color[1], color[2])
            sec.section.color(color)

            sec.baseFrame = turtle.Turtle()
            sec.endFrame = turtle.Turtle()


            sec.curve = turtle.Turtle()
            sec.curve.color(&#39;green&#39;)
            sec.curve.hideturtle()

    def genActionSet(self):
        &#34;&#34;&#34;
        genActionSet is used to generate tuples of all the possible actions
        where each element represents (secNum, action)
        :return: None
        &#34;&#34;&#34;
        actions = []
        for i in range(len(self.sections)):
            for j in range(len(self.controls)):
                a = (i+1, self.controls[j])
                actions.append(a)
        self.actions = actions

class Environment:

    def __init__(self, robot: Robot):
        &#34;&#34;&#34;
        Environment class holds the entire game. Where the
        robot(made out of several sections) is the player. And the
        purpose of the game is to capture as many points as possible
        without hitting any obstacles in between
        :param robot: Section
        &#34;&#34;&#34;
        self.wn = None

        self.ground = self.taskSpace = self.checkTipPoint = None

        self.end = False

        self.robot = robot
        self.capPoints = 0
        self.points = []
        self.generatePoint()

        self.rewardTool = None
        self.pointTool = None

        self.prevState = []
        self.prevState.extend(robot.getAllSectionConfigurations())
        self.prevState.extend(self.points[0])

        self.reward = 0
        self.cReward = 0
        self.currentState = self.prevState
        dist = distance(self.points[0], robot.endEffectorPos())
        self.lastDist = dist

        self.observation = Observation(self.prevState, self.prevState, self.reward, 1, self.end)

    def drawTaskSpace(self):
        &#34;&#34;&#34;
        drawTaskSpace is not in use yet
        :return:
        &#34;&#34;&#34;

        tool = self.taskSpace[&#39;tool&#39;]

        def makeLine(length):
            for i in range(length):
                tool.forward(1)

        tool.up()
        tool.color(&#34;green&#34;)
        tool.home()
        tool.width(7)

        tool.down()
        makeLine(100)

        tool.up()
        tool.home()
        tool.right(180)
        tool.down()
        makeLine(100)

        tool.up()
        tool.right(90)
        tool.down()
        makeLine(130)

        tool.up()
        tool.right(90)
        tool.down()
        makeLine(200)

    def drawGround(self):
        &#34;&#34;&#34;
        drawGround will draw the initial base line of the game
        currently holds no physics
        :return: None
        &#34;&#34;&#34;
        self.wn.tracer(600)

        self.ground.color(&#34;black&#34;)
        self.ground.down()

        for i in range(300):
            self.ground.dot()
            self.ground.forward(1)

        self.ground.home()
        self.ground.right(-180)

        self.ground.down()
        for i in range(300):
            self.ground.dot()
            self.ground.forward(1)

        self.ground.up()
        self.ground.home()

    def drawReward(self):
        &#34;&#34;&#34;
        drawReward will draws out the current reward counter
        (ie: how many points the robot has been able to capture)
        :return:
        &#34;&#34;&#34;
        self.rewardTool.clear()
        self.rewardTool.color(&#39;black&#39;)
        self.rewardTool.up()
        self.rewardTool.setpos(0, -50)
        self.rewardTool.down()
        self.rewardTool.write(&#34;Points: &#34; + str(self.capPoints), align=&#39;center&#39;)

    def buildRenderComponents(self):
        &#34;&#34;&#34;
        buildRenderComponents is used when render is enabled. Assigns turtle objects to each of the
        corresponding tools
        :return: None
        &#34;&#34;&#34;
        self.ground = turtle.Turtle()
        self.ground.hideturtle()

        self.taskSpace = {&#39;dim&#39;: (100, 100),
                          &#39;tool&#39;: turtle.Turtle()}
        self.taskSpace[&#39;tool&#39;].hideturtle()


        self.checkTipPoint = turtle.Turtle()
        self.checkTipPoint.hideturtle()

        self.rewardTool = turtle.Turtle()
        self.rewardTool.hideturtle()

        self.pointTool = turtle.Turtle()
        self.pointTool.hideturtle()

    def render(self):
        &#34;&#34;&#34;
        render is used to draw/update the current environment, and the configuration of the robot
        :return:
        &#34;&#34;&#34;
        if self.wn is None:
            turtle.setup(800, 1000)
            self.wn = turtle.Screen()
            # self.wn.delay(0)
            # self.wn.tracer(600)
            self.robot.eRender = True
            self.robot.buildRenderComponents()
            self.buildRenderComponents()

            self.drawGround()
            # self.robot.setRender(True)

            # self.robot.drawSection(self.robot.currentAngle)
            # self.robot.displayCurve()

        self.robot.render()

        self.drawReward()
        turtle.Screen().update()
        self.drawPoint()

    def pointCapture(self):
        &#34;&#34;&#34;
        pointCapture checks if robot tipPosition is within a
        10 Point radius of the un-captured Point. if so, accumulate
        the points and generate a new random points
        :return: None
        &#34;&#34;&#34;
        tipPos = self.robot.endEffectorPos()

        pCap = None
        for i in range(len(self.points)):
            # Get Distance

            pos = self.points[i]

            c = distance(pos, tipPos)

            # print(&#34;C Val: &#34;, c)
            if c &lt;= 10:
                self.capPoints += 1
                pCap = i
                print(&#34;Captured Point: Points &#34;, self.capPoints)
                break
        if pCap is not None:
            self.points[pCap].clear()
            self.points.pop(pCap)
            self.generatePoint()
            return True
        return False

    def getObservation(self):
        # Current State, reward
        &#34;&#34;&#34;
        getter function for the last observation
        :return: Observation item
        &#34;&#34;&#34;
        return self.observation

    def generatePoint(self):
        &#34;&#34;&#34;
        generatePoint generates a random point based on the
        robot maxSection - minSection and maxCurvature - minCurvature
        :return: (x, y)
        &#34;&#34;&#34;

        maxHeight = len(self.robot.sections) * 100
        maxWidth = 100

        x = random.uniform(-maxWidth, maxWidth)
        y = random.uniform(100, maxHeight)
        point = [x,y]
        self.points.append(point)

        &#39;&#39;&#39;
        Codes to Pick from the curvature of a single section
        
        angle = random.uniform(-2 * math.pi, 2 * math.pi)
        maxArcLen = self.robot.maxSectionLen
        minArcLen = self.robot.minSectionLen

        arcLen = random.randint(minArcLen, maxArcLen)

        radius = arcLen / angle

        t = np.linspace(0, angle, arcLen)
        x = radius * np.cos(t)
        y = radius * np.sin(t)

        point = [x[arcLen - 1] - radius, y[arcLen - 1]]
        self.points.append(point)
        &#39;&#39;&#39;
        return [x, y]

    def staticPoint(self, point):
        &#34;&#34;&#34;
        staticPoint can be used to specify a goal point/position
        :param point: int tuple of len 2
        :return: None
        &#34;&#34;&#34;
        self.points = []
        self.points.append(point)

    def drawPoint(self):
        &#34;&#34;&#34;
        drawPoint generates a random point, draws a point on board
        :return: None
        &#34;&#34;&#34;
        p = self.points[0]
        point = self.pointTool
        point.clear()

        # point = turtle.Turtle()
        # point.hideturtle()

        point.up()

        point.setpos(p[0], p[1])
        point.color(&#39;blue&#39;)
        point.down()
        point.dot(4)
        point.up()

    def done(self):
        &#34;&#34;&#34;
        dones is used to check if a point has been captured or not
        :return: Boolean
        &#34;&#34;&#34;
        return self.end

    def reset(self):
        &#34;&#34;&#34;
        reset function is used reset the robot configurations as well as the total rewards to 0.
        :return: None
        &#34;&#34;&#34;
        self.end = False
        self.capPoints = 0
        self.robot.reset()

        # self.points = []
        self.generatePoint()
        self.reward = 0
        self.prevState = []
        self.prevState.extend(self.robot.getAllSectionConfigurations())
        self.prevState.extend(self.points[0])
        # self.prevState.append(distance(self.points[0], self.robot.endEffectorPos()))

        self.currentState = self.prevState

    def robotStep(self, sec, direction):
        &#34;&#34;&#34;
        robotStep will take a step towards the specified direction
        :param direction: integer (0,1,2,3)
        :return: Observation
        &#34;&#34;&#34;

        # self.robot.step(sec, direction)


        robot = self.robot
        # Save previous state
        self.prevState = self.currentState

        # Step
        limit = self.robot.step(sec, direction)

        self.currentState = []
        self.currentState.extend(robot.getAllSectionConfigurations())
        self.currentState.extend(self.points[0])

        dist = distance(self.points[0], robot.endEffectorPos())

        if dist &lt; self.lastDist:
            self.reward = 1
        else:
            self.reward = -1

        if not limit:
            self.reward = -2


        self.lastDist = dist
        # Determine if a point was captured
        capPoint = self.pointCapture()
        if capPoint:
            self.reward = 200
            self.end = True

        # self.reward = self.reward * (-1)
        self.cReward += self.reward

        self.observation = Observation(self.prevState,
                                       self.currentState,
                                       self.reward,
                                       self.robot.actions.index((sec, direction)),
                                       self.end)
        # print(self.observation)
        return self.observation</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="environment.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a
:param a:
:param b:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(a, b):
    &#34;&#34;&#34;
    Computes a
    :param a:
    :param b:
    :return:
    &#34;&#34;&#34;
    x = a[0] - b[0]
    y = a[1] - b[1]
    return math.sqrt(x ** 2 + y ** 2)</code></pre>
</details>
</dd>
<dt id="environment.randint"><code class="name flex">
<span>def <span class="ident">randint</span></span>(<span>low, high=None, size=None, dtype=builtins.int)</span>
</code></dt>
<dd>
<div class="desc"><p>Return random integers from <code>low</code> (inclusive) to <code>high</code> (exclusive).</p>
<p>Return random integers from the "discrete uniform" distribution of
the specified dtype in the "half-open" interval [<code>low</code>, <code>high</code>). If
<code>high</code> is None (the default), then results are from [0, <code>low</code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New code should use the <code>integers</code> method of a <code>default_rng()</code>
instance instead; see <code>random-quick-start</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>low</code></strong> :&ensp;<code>int</code> or <code>array-like</code> of <code>ints</code></dt>
<dd>Lowest (signed) integers to be drawn from the distribution (unless
<code>high=None</code>, in which case this parameter is one above the
<em>highest</em> such integer).</dd>
<dt><strong><code>high</code></strong> :&ensp;<code>int</code> or <code>array-like</code> of <code>ints</code>, optional</dt>
<dd>If provided, one above the largest (signed) integer to be drawn
from the distribution (see above for behavior if <code>high=None</code>).
If array-like, must contain integer values</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code> or <code>tuple</code> of <code>ints</code>, optional</dt>
<dd>Output shape.
If the given shape is, e.g., <code>(m, n, k)</code>, then
<code>m * n * k</code> samples are drawn.
Default is None, in which case a
single value is returned.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>dtype</code>, optional</dt>
<dd>
<p>Desired dtype of the result. Byteorder must be native.
The default value is int.</p>
<div class="admonition versionadded">
<p class="admonition-title">Added in version:&ensp;1.11.0</p>
</div>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>int</code> or <code>ndarray</code> of <code>ints</code></dt>
<dd><code>size</code>-shaped array of random integers from the appropriate
distribution, or a single such random int if <code>size</code> not provided.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>random_integers</code></dt>
<dd>similar to <code><a title="environment.randint" href="#environment.randint">RandomState.randint()</a></code>, only for the closed interval [<code>low</code>, <code>high</code>], and 1 is the lowest value if <code>high</code> is omitted.</dd>
<dt><code>Generator.integers</code></dt>
<dd>which should be used for new code.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; np.random.randint(2, size=10)
array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random
&gt;&gt;&gt; np.random.randint(1, size=10)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
</code></pre>
<p>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</p>
<pre><code class="python">&gt;&gt;&gt; np.random.randint(5, size=(2, 4))
array([[4, 0, 2, 1], # random
       [3, 2, 2, 0]])
</code></pre>
<p>Generate a 1 x 3 array with 3 different upper bounds</p>
<pre><code class="python">&gt;&gt;&gt; np.random.randint(1, [3, 5, 10])
array([2, 2, 9]) # random
</code></pre>
<p>Generate a 1 by 3 array with 3 different lower bounds</p>
<pre><code class="python">&gt;&gt;&gt; np.random.randint([1, 5, 7], 10)
array([9, 8, 7]) # random
</code></pre>
<p>Generate a 2 by 4 array using broadcasting with dtype of uint8</p>
<pre><code class="python">&gt;&gt;&gt; np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)
array([[ 8,  6,  9,  7], # random
       [ 1, 16,  9, 12]], dtype=uint8)
</code></pre></div>
</dd>
<dt id="environment.random_color"><code class="name flex">
<span>def <span class="ident">random_color</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_color():
    rgbl=[255,0,0]
    random.shuffle(rgbl)
    return (rgbl)</code></pre>
</details>
</dd>
<dt id="environment.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reseed a legacy MT19937 BitGenerator</p>
<h2 id="notes">Notes</h2>
<p>This is a convenience, legacy function.</p>
<p>The best practice is to <strong>not</strong> reseed a BitGenerator, rather to
recreate a new one. This method is here for legacy reasons.
This example demonstrates best practice.</p>
<pre><code class="python">&gt;&gt;&gt; from numpy.random import MT19937
&gt;&gt;&gt; from numpy.random import RandomState, SeedSequence
&gt;&gt;&gt; rs = RandomState(MT19937(SeedSequence(123456789)))
# Later, you want to restart the stream
&gt;&gt;&gt; rs = RandomState(MT19937(SeedSequence(987654321)))
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="environment.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
<span>(</span><span>robot: <a title="environment.Robot" href="#environment.Robot">Robot</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Environment class holds the entire game. Where the
robot(made out of several sections) is the player. And the
purpose of the game is to capture as many points as possible
without hitting any obstacles in between
:param robot: Section</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment:

    def __init__(self, robot: Robot):
        &#34;&#34;&#34;
        Environment class holds the entire game. Where the
        robot(made out of several sections) is the player. And the
        purpose of the game is to capture as many points as possible
        without hitting any obstacles in between
        :param robot: Section
        &#34;&#34;&#34;
        self.wn = None

        self.ground = self.taskSpace = self.checkTipPoint = None

        self.end = False

        self.robot = robot
        self.capPoints = 0
        self.points = []
        self.generatePoint()

        self.rewardTool = None
        self.pointTool = None

        self.prevState = []
        self.prevState.extend(robot.getAllSectionConfigurations())
        self.prevState.extend(self.points[0])

        self.reward = 0
        self.cReward = 0
        self.currentState = self.prevState
        dist = distance(self.points[0], robot.endEffectorPos())
        self.lastDist = dist

        self.observation = Observation(self.prevState, self.prevState, self.reward, 1, self.end)

    def drawTaskSpace(self):
        &#34;&#34;&#34;
        drawTaskSpace is not in use yet
        :return:
        &#34;&#34;&#34;

        tool = self.taskSpace[&#39;tool&#39;]

        def makeLine(length):
            for i in range(length):
                tool.forward(1)

        tool.up()
        tool.color(&#34;green&#34;)
        tool.home()
        tool.width(7)

        tool.down()
        makeLine(100)

        tool.up()
        tool.home()
        tool.right(180)
        tool.down()
        makeLine(100)

        tool.up()
        tool.right(90)
        tool.down()
        makeLine(130)

        tool.up()
        tool.right(90)
        tool.down()
        makeLine(200)

    def drawGround(self):
        &#34;&#34;&#34;
        drawGround will draw the initial base line of the game
        currently holds no physics
        :return: None
        &#34;&#34;&#34;
        self.wn.tracer(600)

        self.ground.color(&#34;black&#34;)
        self.ground.down()

        for i in range(300):
            self.ground.dot()
            self.ground.forward(1)

        self.ground.home()
        self.ground.right(-180)

        self.ground.down()
        for i in range(300):
            self.ground.dot()
            self.ground.forward(1)

        self.ground.up()
        self.ground.home()

    def drawReward(self):
        &#34;&#34;&#34;
        drawReward will draws out the current reward counter
        (ie: how many points the robot has been able to capture)
        :return:
        &#34;&#34;&#34;
        self.rewardTool.clear()
        self.rewardTool.color(&#39;black&#39;)
        self.rewardTool.up()
        self.rewardTool.setpos(0, -50)
        self.rewardTool.down()
        self.rewardTool.write(&#34;Points: &#34; + str(self.capPoints), align=&#39;center&#39;)

    def buildRenderComponents(self):
        &#34;&#34;&#34;
        buildRenderComponents is used when render is enabled. Assigns turtle objects to each of the
        corresponding tools
        :return: None
        &#34;&#34;&#34;
        self.ground = turtle.Turtle()
        self.ground.hideturtle()

        self.taskSpace = {&#39;dim&#39;: (100, 100),
                          &#39;tool&#39;: turtle.Turtle()}
        self.taskSpace[&#39;tool&#39;].hideturtle()


        self.checkTipPoint = turtle.Turtle()
        self.checkTipPoint.hideturtle()

        self.rewardTool = turtle.Turtle()
        self.rewardTool.hideturtle()

        self.pointTool = turtle.Turtle()
        self.pointTool.hideturtle()

    def render(self):
        &#34;&#34;&#34;
        render is used to draw/update the current environment, and the configuration of the robot
        :return:
        &#34;&#34;&#34;
        if self.wn is None:
            turtle.setup(800, 1000)
            self.wn = turtle.Screen()
            # self.wn.delay(0)
            # self.wn.tracer(600)
            self.robot.eRender = True
            self.robot.buildRenderComponents()
            self.buildRenderComponents()

            self.drawGround()
            # self.robot.setRender(True)

            # self.robot.drawSection(self.robot.currentAngle)
            # self.robot.displayCurve()

        self.robot.render()

        self.drawReward()
        turtle.Screen().update()
        self.drawPoint()

    def pointCapture(self):
        &#34;&#34;&#34;
        pointCapture checks if robot tipPosition is within a
        10 Point radius of the un-captured Point. if so, accumulate
        the points and generate a new random points
        :return: None
        &#34;&#34;&#34;
        tipPos = self.robot.endEffectorPos()

        pCap = None
        for i in range(len(self.points)):
            # Get Distance

            pos = self.points[i]

            c = distance(pos, tipPos)

            # print(&#34;C Val: &#34;, c)
            if c &lt;= 10:
                self.capPoints += 1
                pCap = i
                print(&#34;Captured Point: Points &#34;, self.capPoints)
                break
        if pCap is not None:
            self.points[pCap].clear()
            self.points.pop(pCap)
            self.generatePoint()
            return True
        return False

    def getObservation(self):
        # Current State, reward
        &#34;&#34;&#34;
        getter function for the last observation
        :return: Observation item
        &#34;&#34;&#34;
        return self.observation

    def generatePoint(self):
        &#34;&#34;&#34;
        generatePoint generates a random point based on the
        robot maxSection - minSection and maxCurvature - minCurvature
        :return: (x, y)
        &#34;&#34;&#34;

        maxHeight = len(self.robot.sections) * 100
        maxWidth = 100

        x = random.uniform(-maxWidth, maxWidth)
        y = random.uniform(100, maxHeight)
        point = [x,y]
        self.points.append(point)

        &#39;&#39;&#39;
        Codes to Pick from the curvature of a single section
        
        angle = random.uniform(-2 * math.pi, 2 * math.pi)
        maxArcLen = self.robot.maxSectionLen
        minArcLen = self.robot.minSectionLen

        arcLen = random.randint(minArcLen, maxArcLen)

        radius = arcLen / angle

        t = np.linspace(0, angle, arcLen)
        x = radius * np.cos(t)
        y = radius * np.sin(t)

        point = [x[arcLen - 1] - radius, y[arcLen - 1]]
        self.points.append(point)
        &#39;&#39;&#39;
        return [x, y]

    def staticPoint(self, point):
        &#34;&#34;&#34;
        staticPoint can be used to specify a goal point/position
        :param point: int tuple of len 2
        :return: None
        &#34;&#34;&#34;
        self.points = []
        self.points.append(point)

    def drawPoint(self):
        &#34;&#34;&#34;
        drawPoint generates a random point, draws a point on board
        :return: None
        &#34;&#34;&#34;
        p = self.points[0]
        point = self.pointTool
        point.clear()

        # point = turtle.Turtle()
        # point.hideturtle()

        point.up()

        point.setpos(p[0], p[1])
        point.color(&#39;blue&#39;)
        point.down()
        point.dot(4)
        point.up()

    def done(self):
        &#34;&#34;&#34;
        dones is used to check if a point has been captured or not
        :return: Boolean
        &#34;&#34;&#34;
        return self.end

    def reset(self):
        &#34;&#34;&#34;
        reset function is used reset the robot configurations as well as the total rewards to 0.
        :return: None
        &#34;&#34;&#34;
        self.end = False
        self.capPoints = 0
        self.robot.reset()

        # self.points = []
        self.generatePoint()
        self.reward = 0
        self.prevState = []
        self.prevState.extend(self.robot.getAllSectionConfigurations())
        self.prevState.extend(self.points[0])
        # self.prevState.append(distance(self.points[0], self.robot.endEffectorPos()))

        self.currentState = self.prevState

    def robotStep(self, sec, direction):
        &#34;&#34;&#34;
        robotStep will take a step towards the specified direction
        :param direction: integer (0,1,2,3)
        :return: Observation
        &#34;&#34;&#34;

        # self.robot.step(sec, direction)


        robot = self.robot
        # Save previous state
        self.prevState = self.currentState

        # Step
        limit = self.robot.step(sec, direction)

        self.currentState = []
        self.currentState.extend(robot.getAllSectionConfigurations())
        self.currentState.extend(self.points[0])

        dist = distance(self.points[0], robot.endEffectorPos())

        if dist &lt; self.lastDist:
            self.reward = 1
        else:
            self.reward = -1

        if not limit:
            self.reward = -2


        self.lastDist = dist
        # Determine if a point was captured
        capPoint = self.pointCapture()
        if capPoint:
            self.reward = 200
            self.end = True

        # self.reward = self.reward * (-1)
        self.cReward += self.reward

        self.observation = Observation(self.prevState,
                                       self.currentState,
                                       self.reward,
                                       self.robot.actions.index((sec, direction)),
                                       self.end)
        # print(self.observation)
        return self.observation</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="environment.Environment.buildRenderComponents"><code class="name flex">
<span>def <span class="ident">buildRenderComponents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>buildRenderComponents is used when render is enabled. Assigns turtle objects to each of the
corresponding tools
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildRenderComponents(self):
    &#34;&#34;&#34;
    buildRenderComponents is used when render is enabled. Assigns turtle objects to each of the
    corresponding tools
    :return: None
    &#34;&#34;&#34;
    self.ground = turtle.Turtle()
    self.ground.hideturtle()

    self.taskSpace = {&#39;dim&#39;: (100, 100),
                      &#39;tool&#39;: turtle.Turtle()}
    self.taskSpace[&#39;tool&#39;].hideturtle()


    self.checkTipPoint = turtle.Turtle()
    self.checkTipPoint.hideturtle()

    self.rewardTool = turtle.Turtle()
    self.rewardTool.hideturtle()

    self.pointTool = turtle.Turtle()
    self.pointTool.hideturtle()</code></pre>
</details>
</dd>
<dt id="environment.Environment.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>dones is used to check if a point has been captured or not
:return: Boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done(self):
    &#34;&#34;&#34;
    dones is used to check if a point has been captured or not
    :return: Boolean
    &#34;&#34;&#34;
    return self.end</code></pre>
</details>
</dd>
<dt id="environment.Environment.drawGround"><code class="name flex">
<span>def <span class="ident">drawGround</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>drawGround will draw the initial base line of the game
currently holds no physics
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawGround(self):
    &#34;&#34;&#34;
    drawGround will draw the initial base line of the game
    currently holds no physics
    :return: None
    &#34;&#34;&#34;
    self.wn.tracer(600)

    self.ground.color(&#34;black&#34;)
    self.ground.down()

    for i in range(300):
        self.ground.dot()
        self.ground.forward(1)

    self.ground.home()
    self.ground.right(-180)

    self.ground.down()
    for i in range(300):
        self.ground.dot()
        self.ground.forward(1)

    self.ground.up()
    self.ground.home()</code></pre>
</details>
</dd>
<dt id="environment.Environment.drawPoint"><code class="name flex">
<span>def <span class="ident">drawPoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>drawPoint generates a random point, draws a point on board
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawPoint(self):
    &#34;&#34;&#34;
    drawPoint generates a random point, draws a point on board
    :return: None
    &#34;&#34;&#34;
    p = self.points[0]
    point = self.pointTool
    point.clear()

    # point = turtle.Turtle()
    # point.hideturtle()

    point.up()

    point.setpos(p[0], p[1])
    point.color(&#39;blue&#39;)
    point.down()
    point.dot(4)
    point.up()</code></pre>
</details>
</dd>
<dt id="environment.Environment.drawReward"><code class="name flex">
<span>def <span class="ident">drawReward</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>drawReward will draws out the current reward counter
(ie: how many points the robot has been able to capture)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawReward(self):
    &#34;&#34;&#34;
    drawReward will draws out the current reward counter
    (ie: how many points the robot has been able to capture)
    :return:
    &#34;&#34;&#34;
    self.rewardTool.clear()
    self.rewardTool.color(&#39;black&#39;)
    self.rewardTool.up()
    self.rewardTool.setpos(0, -50)
    self.rewardTool.down()
    self.rewardTool.write(&#34;Points: &#34; + str(self.capPoints), align=&#39;center&#39;)</code></pre>
</details>
</dd>
<dt id="environment.Environment.drawTaskSpace"><code class="name flex">
<span>def <span class="ident">drawTaskSpace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>drawTaskSpace is not in use yet
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawTaskSpace(self):
    &#34;&#34;&#34;
    drawTaskSpace is not in use yet
    :return:
    &#34;&#34;&#34;

    tool = self.taskSpace[&#39;tool&#39;]

    def makeLine(length):
        for i in range(length):
            tool.forward(1)

    tool.up()
    tool.color(&#34;green&#34;)
    tool.home()
    tool.width(7)

    tool.down()
    makeLine(100)

    tool.up()
    tool.home()
    tool.right(180)
    tool.down()
    makeLine(100)

    tool.up()
    tool.right(90)
    tool.down()
    makeLine(130)

    tool.up()
    tool.right(90)
    tool.down()
    makeLine(200)</code></pre>
</details>
</dd>
<dt id="environment.Environment.generatePoint"><code class="name flex">
<span>def <span class="ident">generatePoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>generatePoint generates a random point based on the
robot maxSection - minSection and maxCurvature - minCurvature
:return: (x, y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generatePoint(self):
    &#34;&#34;&#34;
    generatePoint generates a random point based on the
    robot maxSection - minSection and maxCurvature - minCurvature
    :return: (x, y)
    &#34;&#34;&#34;

    maxHeight = len(self.robot.sections) * 100
    maxWidth = 100

    x = random.uniform(-maxWidth, maxWidth)
    y = random.uniform(100, maxHeight)
    point = [x,y]
    self.points.append(point)

    &#39;&#39;&#39;
    Codes to Pick from the curvature of a single section
    
    angle = random.uniform(-2 * math.pi, 2 * math.pi)
    maxArcLen = self.robot.maxSectionLen
    minArcLen = self.robot.minSectionLen

    arcLen = random.randint(minArcLen, maxArcLen)

    radius = arcLen / angle

    t = np.linspace(0, angle, arcLen)
    x = radius * np.cos(t)
    y = radius * np.sin(t)

    point = [x[arcLen - 1] - radius, y[arcLen - 1]]
    self.points.append(point)
    &#39;&#39;&#39;
    return [x, y]</code></pre>
</details>
</dd>
<dt id="environment.Environment.getObservation"><code class="name flex">
<span>def <span class="ident">getObservation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getter function for the last observation
:return: Observation item</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getObservation(self):
    # Current State, reward
    &#34;&#34;&#34;
    getter function for the last observation
    :return: Observation item
    &#34;&#34;&#34;
    return self.observation</code></pre>
</details>
</dd>
<dt id="environment.Environment.pointCapture"><code class="name flex">
<span>def <span class="ident">pointCapture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>pointCapture checks if robot tipPosition is within a
10 Point radius of the un-captured Point. if so, accumulate
the points and generate a new random points
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pointCapture(self):
    &#34;&#34;&#34;
    pointCapture checks if robot tipPosition is within a
    10 Point radius of the un-captured Point. if so, accumulate
    the points and generate a new random points
    :return: None
    &#34;&#34;&#34;
    tipPos = self.robot.endEffectorPos()

    pCap = None
    for i in range(len(self.points)):
        # Get Distance

        pos = self.points[i]

        c = distance(pos, tipPos)

        # print(&#34;C Val: &#34;, c)
        if c &lt;= 10:
            self.capPoints += 1
            pCap = i
            print(&#34;Captured Point: Points &#34;, self.capPoints)
            break
    if pCap is not None:
        self.points[pCap].clear()
        self.points.pop(pCap)
        self.generatePoint()
        return True
    return False</code></pre>
</details>
</dd>
<dt id="environment.Environment.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>render is used to draw/update the current environment, and the configuration of the robot
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self):
    &#34;&#34;&#34;
    render is used to draw/update the current environment, and the configuration of the robot
    :return:
    &#34;&#34;&#34;
    if self.wn is None:
        turtle.setup(800, 1000)
        self.wn = turtle.Screen()
        # self.wn.delay(0)
        # self.wn.tracer(600)
        self.robot.eRender = True
        self.robot.buildRenderComponents()
        self.buildRenderComponents()

        self.drawGround()
        # self.robot.setRender(True)

        # self.robot.drawSection(self.robot.currentAngle)
        # self.robot.displayCurve()

    self.robot.render()

    self.drawReward()
    turtle.Screen().update()
    self.drawPoint()</code></pre>
</details>
</dd>
<dt id="environment.Environment.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>reset function is used reset the robot configurations as well as the total rewards to 0.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;
    reset function is used reset the robot configurations as well as the total rewards to 0.
    :return: None
    &#34;&#34;&#34;
    self.end = False
    self.capPoints = 0
    self.robot.reset()

    # self.points = []
    self.generatePoint()
    self.reward = 0
    self.prevState = []
    self.prevState.extend(self.robot.getAllSectionConfigurations())
    self.prevState.extend(self.points[0])
    # self.prevState.append(distance(self.points[0], self.robot.endEffectorPos()))

    self.currentState = self.prevState</code></pre>
</details>
</dd>
<dt id="environment.Environment.robotStep"><code class="name flex">
<span>def <span class="ident">robotStep</span></span>(<span>self, sec, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>robotStep will take a step towards the specified direction
:param direction: integer (0,1,2,3)
:return: Observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def robotStep(self, sec, direction):
    &#34;&#34;&#34;
    robotStep will take a step towards the specified direction
    :param direction: integer (0,1,2,3)
    :return: Observation
    &#34;&#34;&#34;

    # self.robot.step(sec, direction)


    robot = self.robot
    # Save previous state
    self.prevState = self.currentState

    # Step
    limit = self.robot.step(sec, direction)

    self.currentState = []
    self.currentState.extend(robot.getAllSectionConfigurations())
    self.currentState.extend(self.points[0])

    dist = distance(self.points[0], robot.endEffectorPos())

    if dist &lt; self.lastDist:
        self.reward = 1
    else:
        self.reward = -1

    if not limit:
        self.reward = -2


    self.lastDist = dist
    # Determine if a point was captured
    capPoint = self.pointCapture()
    if capPoint:
        self.reward = 200
        self.end = True

    # self.reward = self.reward * (-1)
    self.cReward += self.reward

    self.observation = Observation(self.prevState,
                                   self.currentState,
                                   self.reward,
                                   self.robot.actions.index((sec, direction)),
                                   self.end)
    # print(self.observation)
    return self.observation</code></pre>
</details>
</dd>
<dt id="environment.Environment.staticPoint"><code class="name flex">
<span>def <span class="ident">staticPoint</span></span>(<span>self, point)</span>
</code></dt>
<dd>
<div class="desc"><p>staticPoint can be used to specify a goal point/position
:param point: int tuple of len 2
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def staticPoint(self, point):
    &#34;&#34;&#34;
    staticPoint can be used to specify a goal point/position
    :param point: int tuple of len 2
    :return: None
    &#34;&#34;&#34;
    self.points = []
    self.points.append(point)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="environment.Observation"><code class="flex name class">
<span>class <span class="ident">Observation</span></span>
<span>(</span><span>state: Any, nextState: Any, reward: float, action: float, done: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Observation(state: Any, nextState: Any, reward: float, action: float, done: bool)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Observation:
    state: Any
    nextState: Any
    reward: float
    action: float
    done: bool</code></pre>
</details>
</dd>
<dt id="environment.Robot"><code class="flex name class">
<span>class <span class="ident">Robot</span></span>
</code></dt>
<dd>
<div class="desc"><p>Robot class is a super class, which can be used to
make a series of sections to work together.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Robot:
    def __init__(self):
        &#39;&#39;&#39;
        Robot class is a super class, which can be used to
        make a series of sections to work together.
        &#39;&#39;&#39;
        self.sections = []
        self.zero = 0.00001
        self.tipPosition = 0
        self.controlNum = {
            &#39;l&#39;: 0, &#39;r&#39;: 1, &#39;e&#39;: 2, &#39;c&#39;: 3
        }
        self.controls = [&#39;l&#39;,&#39;r&#39;,&#39;e&#39;,&#39;c&#39;]
        self.actions = []
        self.eRender = False

    def newSection(self):
        &#39;&#39;&#39;
        newSection creates a new section and adds it to the end of
        the robot. Default section is 100
        :return: None
        &#39;&#39;&#39;
        newSection = section(100, 20)
        angles = self.getAllCurrentAngles()
        if len(self.sections) &gt;= 1:
            newTip = self.sections[-1].getTipPos(angles)
            newSection.setBaseLocation(newTip[0], newTip[1])

        # if self.eRender:
        #     turtle.Screen().colormode(255)
        #     color = tuple(np.random.choice(range(255), size=3))
        #     newSection.section.color(color[0], color[1], color[2])

        self.sections.append(newSection)
        self.genActionSet()

    def getAllCurrentAngles(self):
        &#39;&#39;&#39;
        getAllCurrentAngles gets the curvature angle for each section
        :return: list[float]
        &#39;&#39;&#39;
        angles = []
        for i in range(len(self.sections)):
            angle = self.sections[i].currentAngle
            # if angle != self.zero:
            angles.append(angle)

        return angles

    def getAllSectionConfigurations(self):
        &#34;&#34;&#34;
        getAllSectionConfigurations is used to get the current curvature and length of
        each section of the robot
        :return:
        &#34;&#34;&#34;
        angles = self.getAllCurrentAngles()
        configs = []
        for i in range(len(self.sections)):
            angle = angles[i]
            secLen = self.sections[i].sectionLen
            config = (angle, secLen)
            configs.extend(config)

        return configs

    def step(self, secNum, action):
        &#39;&#39;&#39;
        step methods will conduct the given action for the given section
        :param secNum: Section number in the robot (index starting at 1)
        :param action: action (l,r,c,e)
        :return:  None
        &#39;&#39;&#39;
        secNum -= 1
        # # Base Section

        stepLimitReached = self.sections[secNum].controls[action]()

        angles = self.getAllCurrentAngles()

        tipPos = self.sections[secNum].getTipPos(angles[:secNum])
        i = secNum + 1
        while i &lt; len(self.sections):

            self.sections[i].setBaseLocation(tipPos[0], tipPos[1])

            tipPos = self.sections[i].getTipPos(angles[:i])
            i += 1

        return stepLimitReached

    def endEffectorPos(self):
        &#34;&#34;&#34;
        endEffectorPos is used to determine where tip position of the robot is currently
        :return: tuple of coordinates
        &#34;&#34;&#34;
        lastSection = self.sections[len(self.sections) - 1]
        transformations = self.getAllCurrentAngles()
        tipPos = lastSection.getTipPos(transformations[:len(self.sections) - 1])

        return tipPos

    def randomAction(self):
        &#34;&#34;&#34;
        randomAction picks a random action to take for the robot
        :return:
        &#34;&#34;&#34;
        action = randint(0, len(self.actions))
        return self.actions[action]

    def reset(self):
        &#34;&#34;&#34;
        reset, will delete the old robot sections and generate a robot with the same
        number of sections
        :return: None
        &#34;&#34;&#34;
        currentSecs = len(self.sections)
        self.sections = []
        for i in range(currentSecs):
            self.newSection()

    def render(self):
        &#39;&#39;&#39;
        render will draw out each section
        :return:
        &#39;&#39;&#39;
        angles = self.getAllCurrentAngles()
        for i in range(len(self.sections)):
            # print(&#34;--------- Section &#34; + str(i) + &#39;-----------&#39;)
            sec = self.sections[i]
            transformations = angles[:i]
            # print(&#39;\t transformations:&#39;, transformations)
            sec.drawSection(transformations)
            # sec.displayCurve(transformations)
            # sec.displayCurve(transformations)

    def buildRenderComponents(self):
        &#34;&#34;&#34;
        buildRenderComponents is used to assign turtle tools to components
        that are required to draw out the entire robot
        :return: Nones
        &#34;&#34;&#34;
        for i in range(len(self.sections)):
            sec = self.sections[i]
            sec.section = turtle.Turtle()
            sec.section.width(2)
            sec.section.hideturtle()
            # color = tuple(np.random.choice(range(255), size=3))
            color = colors[random.randint(0, len(colors)-1)]
            # sec.section.color(color[0], color[1], color[2])
            sec.section.color(color)

            sec.baseFrame = turtle.Turtle()
            sec.endFrame = turtle.Turtle()


            sec.curve = turtle.Turtle()
            sec.curve.color(&#39;green&#39;)
            sec.curve.hideturtle()

    def genActionSet(self):
        &#34;&#34;&#34;
        genActionSet is used to generate tuples of all the possible actions
        where each element represents (secNum, action)
        :return: None
        &#34;&#34;&#34;
        actions = []
        for i in range(len(self.sections)):
            for j in range(len(self.controls)):
                a = (i+1, self.controls[j])
                actions.append(a)
        self.actions = actions</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="environment.Robot.buildRenderComponents"><code class="name flex">
<span>def <span class="ident">buildRenderComponents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>buildRenderComponents is used to assign turtle tools to components
that are required to draw out the entire robot
:return: Nones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildRenderComponents(self):
    &#34;&#34;&#34;
    buildRenderComponents is used to assign turtle tools to components
    that are required to draw out the entire robot
    :return: Nones
    &#34;&#34;&#34;
    for i in range(len(self.sections)):
        sec = self.sections[i]
        sec.section = turtle.Turtle()
        sec.section.width(2)
        sec.section.hideturtle()
        # color = tuple(np.random.choice(range(255), size=3))
        color = colors[random.randint(0, len(colors)-1)]
        # sec.section.color(color[0], color[1], color[2])
        sec.section.color(color)

        sec.baseFrame = turtle.Turtle()
        sec.endFrame = turtle.Turtle()


        sec.curve = turtle.Turtle()
        sec.curve.color(&#39;green&#39;)
        sec.curve.hideturtle()</code></pre>
</details>
</dd>
<dt id="environment.Robot.endEffectorPos"><code class="name flex">
<span>def <span class="ident">endEffectorPos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>endEffectorPos is used to determine where tip position of the robot is currently
:return: tuple of coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endEffectorPos(self):
    &#34;&#34;&#34;
    endEffectorPos is used to determine where tip position of the robot is currently
    :return: tuple of coordinates
    &#34;&#34;&#34;
    lastSection = self.sections[len(self.sections) - 1]
    transformations = self.getAllCurrentAngles()
    tipPos = lastSection.getTipPos(transformations[:len(self.sections) - 1])

    return tipPos</code></pre>
</details>
</dd>
<dt id="environment.Robot.genActionSet"><code class="name flex">
<span>def <span class="ident">genActionSet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>genActionSet is used to generate tuples of all the possible actions
where each element represents (secNum, action)
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genActionSet(self):
    &#34;&#34;&#34;
    genActionSet is used to generate tuples of all the possible actions
    where each element represents (secNum, action)
    :return: None
    &#34;&#34;&#34;
    actions = []
    for i in range(len(self.sections)):
        for j in range(len(self.controls)):
            a = (i+1, self.controls[j])
            actions.append(a)
    self.actions = actions</code></pre>
</details>
</dd>
<dt id="environment.Robot.getAllCurrentAngles"><code class="name flex">
<span>def <span class="ident">getAllCurrentAngles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getAllCurrentAngles gets the curvature angle for each section
:return: list[float]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllCurrentAngles(self):
    &#39;&#39;&#39;
    getAllCurrentAngles gets the curvature angle for each section
    :return: list[float]
    &#39;&#39;&#39;
    angles = []
    for i in range(len(self.sections)):
        angle = self.sections[i].currentAngle
        # if angle != self.zero:
        angles.append(angle)

    return angles</code></pre>
</details>
</dd>
<dt id="environment.Robot.getAllSectionConfigurations"><code class="name flex">
<span>def <span class="ident">getAllSectionConfigurations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getAllSectionConfigurations is used to get the current curvature and length of
each section of the robot
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllSectionConfigurations(self):
    &#34;&#34;&#34;
    getAllSectionConfigurations is used to get the current curvature and length of
    each section of the robot
    :return:
    &#34;&#34;&#34;
    angles = self.getAllCurrentAngles()
    configs = []
    for i in range(len(self.sections)):
        angle = angles[i]
        secLen = self.sections[i].sectionLen
        config = (angle, secLen)
        configs.extend(config)

    return configs</code></pre>
</details>
</dd>
<dt id="environment.Robot.newSection"><code class="name flex">
<span>def <span class="ident">newSection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>newSection creates a new section and adds it to the end of
the robot. Default section is 100
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newSection(self):
    &#39;&#39;&#39;
    newSection creates a new section and adds it to the end of
    the robot. Default section is 100
    :return: None
    &#39;&#39;&#39;
    newSection = section(100, 20)
    angles = self.getAllCurrentAngles()
    if len(self.sections) &gt;= 1:
        newTip = self.sections[-1].getTipPos(angles)
        newSection.setBaseLocation(newTip[0], newTip[1])

    # if self.eRender:
    #     turtle.Screen().colormode(255)
    #     color = tuple(np.random.choice(range(255), size=3))
    #     newSection.section.color(color[0], color[1], color[2])

    self.sections.append(newSection)
    self.genActionSet()</code></pre>
</details>
</dd>
<dt id="environment.Robot.randomAction"><code class="name flex">
<span>def <span class="ident">randomAction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>randomAction picks a random action to take for the robot
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomAction(self):
    &#34;&#34;&#34;
    randomAction picks a random action to take for the robot
    :return:
    &#34;&#34;&#34;
    action = randint(0, len(self.actions))
    return self.actions[action]</code></pre>
</details>
</dd>
<dt id="environment.Robot.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>render will draw out each section
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self):
    &#39;&#39;&#39;
    render will draw out each section
    :return:
    &#39;&#39;&#39;
    angles = self.getAllCurrentAngles()
    for i in range(len(self.sections)):
        # print(&#34;--------- Section &#34; + str(i) + &#39;-----------&#39;)
        sec = self.sections[i]
        transformations = angles[:i]
        # print(&#39;\t transformations:&#39;, transformations)
        sec.drawSection(transformations)</code></pre>
</details>
</dd>
<dt id="environment.Robot.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>reset, will delete the old robot sections and generate a robot with the same
number of sections
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;
    reset, will delete the old robot sections and generate a robot with the same
    number of sections
    :return: None
    &#34;&#34;&#34;
    currentSecs = len(self.sections)
    self.sections = []
    for i in range(currentSecs):
        self.newSection()</code></pre>
</details>
</dd>
<dt id="environment.Robot.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, secNum, action)</span>
</code></dt>
<dd>
<div class="desc"><p>step methods will conduct the given action for the given section
:param secNum: Section number in the robot (index starting at 1)
:param action: action (l,r,c,e)
:return:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, secNum, action):
    &#39;&#39;&#39;
    step methods will conduct the given action for the given section
    :param secNum: Section number in the robot (index starting at 1)
    :param action: action (l,r,c,e)
    :return:  None
    &#39;&#39;&#39;
    secNum -= 1
    # # Base Section

    stepLimitReached = self.sections[secNum].controls[action]()

    angles = self.getAllCurrentAngles()

    tipPos = self.sections[secNum].getTipPos(angles[:secNum])
    i = secNum + 1
    while i &lt; len(self.sections):

        self.sections[i].setBaseLocation(tipPos[0], tipPos[1])

        tipPos = self.sections[i].getTipPos(angles[:i])
        i += 1

    return stepLimitReached</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="environment.section"><code class="flex name class">
<span>class <span class="ident">section</span></span>
<span>(</span><span>sectionLen, maxSectionLen)</span>
</code></dt>
<dd>
<div class="desc"><p>Section class represents a single section of a continuum robot</p>
<p>:param sectionLen: Minimum section length</p>
<p>:param maxSectionLen: Maximum Section length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class section:

    def __init__(self, sectionLen, maxSectionLen):
        &#34;&#34;&#34;
        Section class represents a single section of a continuum robot

        :param sectionLen: Minimum section length\n
        :param maxSectionLen: Maximum Section length
        &#34;&#34;&#34;

        self.baseLocation = [0, 0]
        self.baseAngle = 0
        self.transformations = []
        # Set of baseLocations and Angles

        self.section = None
        self.render = False
        self.baseFrame = self.endFrame = None
        self.curve = None


        self.sectionLen = sectionLen
        self.minSectionLen = sectionLen
        self.maxSectionLen = sectionLen +  maxSectionLen

        self.zero = 0.00001
        self.leftLimit = 1.8 * math.pi
        self.currentAngle = self.zero
        self.tipPos = (0, 0)

        self.controls = {
            &#39;l&#39;: self.stepLeft,
            &#39;r&#39;: self.stepRight,
            &#39;e&#39;: self.extendArm,
            &#39;c&#39;: self.contractArm
        }
        self.controlNum = {
            &#39;l&#39;: 0, &#39;r&#39;: 1, &#39;e&#39;: 2, &#39;c&#39;: 3
        }

    def setBaseLocation(self, x, y):
        &#39;&#39;&#39;
        setBaseLocation is used modify the starting position of
        the section.
        :param x: x coordinate of the new base position
        :param y: y coordinate of the new base position
        :return: None
        &#39;&#39;&#39;
        self.baseLocation = [x, y]

    def setRender(self, state):
        &#39;&#39;&#39;
        setRender Method is used enable/disable rendering
        :param state: bool
        :return: None
        &#39;&#39;&#39;
        self.render = state

    def stepLeft(self):
        &#34;&#34;&#34;
        stepLeft function will increase the curvature angle towards 2π
        while the section Length will remain the same. Each step will
        increase the angle by 0.01
        :return: None
        &#34;&#34;&#34;
        # increase by angle by .5 degree
        if self.currentAngle == self.zero:
            self.currentAngle = 0

        self.currentAngle += 0.01
        if self.currentAngle &gt;= self.leftLimit:
            self.currentAngle -= 0.01
            # print(&#34;Left angle limit reached&#34;, self.currentAngle)
            return False

        if self.render:
            self.drawSection(self.currentAngle)

        return True

    def stepRight(self):
        &#34;&#34;&#34;
        stepRight function will decrease the curvature angle towards -2π
        while the section Length will remain the same. Each step will
        decrease the angle by 0.01
        :return: None
        &#34;&#34;&#34;
        # decrease by angle by .5 degree
        if self.currentAngle == self.zero:
            self.currentAngle = 0

        self.currentAngle -= 0.01
        if self.currentAngle &lt;= -self.leftLimit:
            self.currentAngle += 0.01
            # print(&#34;Right angle limit reached&#34;, self.currentAngle)
            return False
        if self.render:
            self.drawSection(self.currentAngle)

        return True

    def extendArm(self):
        &#34;&#34;&#34;
        extendArm will increase the length of section by a single unit
        if the length is below the maximum increase. Curvature will remain
        constant
        :return: None
        &#34;&#34;&#34;

        if self.sectionLen == self.maxSectionLen:
            assert &#34;Section max length has reached&#34;
            return True
        else:
            self.sectionLen += 1
        if self.render:
            self.drawSection(self.currentAngle)
            self.displayCurve()
        return True

    def contractArm(self):
        &#34;&#34;&#34;
        contractArm will decrease the length of section by a single unit
        if the length is above the minimum length. Curvature will remain
        constant
        :return: None
        &#34;&#34;&#34;
        if self.sectionLen == self.minSectionLen:
            assert &#34;Section min length has reached&#34;
            return True
        else:
            self.sectionLen -= 1

        if self.render:
            self.drawSection(self.currentAngle)
            self.displayCurve()

        return True

    def drawSection(self, transformations):
        &#34;&#34;&#34;
        drawSection will draw the current representation of the section
        based on the given angle and current section length
        :param angle: Angle of the curvature. Should not be used
        :return: None
        &#34;&#34;&#34;
        self.section.clear()
        self.section.hideturtle()
        self.section.up()
        self.section.setpos(self.baseLocation[0], self.baseLocation[1])

        angle = self.currentAngle
        if angle == 0:  # Use epsilon difference
            angle = self.zero

        radius = self.sectionLen / angle  # curvature is 0 ==&gt; radius is infinite

        t = np.linspace(0, angle, self.sectionLen)
        x = radius * np.cos(t)
        y = radius * np.sin(t)

        allPoints = np.vstack((x, y)).T
        allPoints[:,0] = allPoints[:,0] - radius


        # print(&#34;\t First Point&#34;, allPoints[0])
        # print(&#34;\t Base Location:&#34;, self.baseLocation)

        for i in range(len(transformations)):
            baseAngle = transformations[i]
            r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                          (np.sin(baseAngle), np.cos(baseAngle))))
            allPoints = np.dot(r, allPoints.T).T

        allPoints[:,0] = allPoints[:,0] + self.baseLocation[0]
        allPoints[:, 1] = allPoints[:, 1] + self.baseLocation[1]

        disk = 1
        for n in range(self.sectionLen):
            px = allPoints[n][0]
            py = allPoints[n][1]

            # if n == 0 or n == self.sectionLen - 1:
            #     print(&#39;\tPoint=&#39; + str(n) + &#39; :&#39;, px, py)

            self.section.down()
            self.section.setpos(px, py)
            if disk % 10 == 0:
               self.section.dot(2)

            disk = disk % 10 + 1
            self.section.up()

        # self.tipPos = (x[len(x) - 1] - radius, y[len(y) - 1])
        self.section.home()

    def getTipPos(self, transformations):
        &#34;&#34;&#34;
        getTipPos return a (x,y) coordinate of where the tip of the section is located
        :return: float
        &#34;&#34;&#34;
        angle = self.currentAngle
        if angle == 0:  # Use epsilon difference
            angle = self.zero

        radius = self.sectionLen / angle  # curvature is 0 ==&gt; radius is infinite

        t = np.linspace(0, angle, self.sectionLen)
        x = radius * np.cos(t)
        y = radius * np.sin(t)

        allPoints = np.vstack((x, y)).T
        allPoints[:, 0] = allPoints[:, 0] - radius

        for i in range(len(transformations)):
            baseAngle = transformations[i]
            r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                          (np.sin(baseAngle), np.cos(baseAngle))))
            allPoints = np.dot(r, allPoints.T).T

        allPoints[:, 0] = allPoints[:, 0] + self.baseLocation[0]
        allPoints[:, 1] = allPoints[:, 1] + self.baseLocation[1]

        px = allPoints[-1][0]
        py = allPoints[-1][1]

        point = [px, py]

        return point

    def displayCurve(self, transformations):
        &#34;&#34;&#34;
        displayCurve is used of visualize all the positions that the
        section can be configured to based on its current section length
        :return: None
        &#34;&#34;&#34;
        tool = self.curve
        tool.clear()
        tool.hideturtle()
        tool.up()

        ang = np.linspace(-2 * math.pi, 2 * math.pi, 500)

        for i in range(len(ang)):
            angle = ang[i]
            radius = self.sectionLen / angle

            t = np.linspace(0, angle, self.sectionLen)
            x = radius * np.cos(t)
            y = radius * np.sin(t)

            x = x[-1]
            y = y[-1]

            x = x - radius
            points = [x,y]
            for i in range(len(transformations)):
                baseAngle = transformations[i]
                r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                              (np.sin(baseAngle), np.cos(baseAngle))))
                points = np.dot(r, points)

            points[0] = points[0] + self.baseLocation[0]
            points[1] = points[1] + self.baseLocation[1]

            self.curve.goto(points[0], points[1])
            self.curve.dot(2, &#39;green&#39;)
            self.curve.up()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="environment.section.contractArm"><code class="name flex">
<span>def <span class="ident">contractArm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>contractArm will decrease the length of section by a single unit
if the length is above the minimum length. Curvature will remain
constant
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contractArm(self):
    &#34;&#34;&#34;
    contractArm will decrease the length of section by a single unit
    if the length is above the minimum length. Curvature will remain
    constant
    :return: None
    &#34;&#34;&#34;
    if self.sectionLen == self.minSectionLen:
        assert &#34;Section min length has reached&#34;
        return True
    else:
        self.sectionLen -= 1

    if self.render:
        self.drawSection(self.currentAngle)
        self.displayCurve()

    return True</code></pre>
</details>
</dd>
<dt id="environment.section.displayCurve"><code class="name flex">
<span>def <span class="ident">displayCurve</span></span>(<span>self, transformations)</span>
</code></dt>
<dd>
<div class="desc"><p>displayCurve is used of visualize all the positions that the
section can be configured to based on its current section length
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def displayCurve(self, transformations):
    &#34;&#34;&#34;
    displayCurve is used of visualize all the positions that the
    section can be configured to based on its current section length
    :return: None
    &#34;&#34;&#34;
    tool = self.curve
    tool.clear()
    tool.hideturtle()
    tool.up()

    ang = np.linspace(-2 * math.pi, 2 * math.pi, 500)

    for i in range(len(ang)):
        angle = ang[i]
        radius = self.sectionLen / angle

        t = np.linspace(0, angle, self.sectionLen)
        x = radius * np.cos(t)
        y = radius * np.sin(t)

        x = x[-1]
        y = y[-1]

        x = x - radius
        points = [x,y]
        for i in range(len(transformations)):
            baseAngle = transformations[i]
            r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                          (np.sin(baseAngle), np.cos(baseAngle))))
            points = np.dot(r, points)

        points[0] = points[0] + self.baseLocation[0]
        points[1] = points[1] + self.baseLocation[1]

        self.curve.goto(points[0], points[1])
        self.curve.dot(2, &#39;green&#39;)
        self.curve.up()</code></pre>
</details>
</dd>
<dt id="environment.section.drawSection"><code class="name flex">
<span>def <span class="ident">drawSection</span></span>(<span>self, transformations)</span>
</code></dt>
<dd>
<div class="desc"><p>drawSection will draw the current representation of the section
based on the given angle and current section length
:param angle: Angle of the curvature. Should not be used
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawSection(self, transformations):
    &#34;&#34;&#34;
    drawSection will draw the current representation of the section
    based on the given angle and current section length
    :param angle: Angle of the curvature. Should not be used
    :return: None
    &#34;&#34;&#34;
    self.section.clear()
    self.section.hideturtle()
    self.section.up()
    self.section.setpos(self.baseLocation[0], self.baseLocation[1])

    angle = self.currentAngle
    if angle == 0:  # Use epsilon difference
        angle = self.zero

    radius = self.sectionLen / angle  # curvature is 0 ==&gt; radius is infinite

    t = np.linspace(0, angle, self.sectionLen)
    x = radius * np.cos(t)
    y = radius * np.sin(t)

    allPoints = np.vstack((x, y)).T
    allPoints[:,0] = allPoints[:,0] - radius


    # print(&#34;\t First Point&#34;, allPoints[0])
    # print(&#34;\t Base Location:&#34;, self.baseLocation)

    for i in range(len(transformations)):
        baseAngle = transformations[i]
        r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                      (np.sin(baseAngle), np.cos(baseAngle))))
        allPoints = np.dot(r, allPoints.T).T

    allPoints[:,0] = allPoints[:,0] + self.baseLocation[0]
    allPoints[:, 1] = allPoints[:, 1] + self.baseLocation[1]

    disk = 1
    for n in range(self.sectionLen):
        px = allPoints[n][0]
        py = allPoints[n][1]

        # if n == 0 or n == self.sectionLen - 1:
        #     print(&#39;\tPoint=&#39; + str(n) + &#39; :&#39;, px, py)

        self.section.down()
        self.section.setpos(px, py)
        if disk % 10 == 0:
           self.section.dot(2)

        disk = disk % 10 + 1
        self.section.up()

    # self.tipPos = (x[len(x) - 1] - radius, y[len(y) - 1])
    self.section.home()</code></pre>
</details>
</dd>
<dt id="environment.section.extendArm"><code class="name flex">
<span>def <span class="ident">extendArm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>extendArm will increase the length of section by a single unit
if the length is below the maximum increase. Curvature will remain
constant
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extendArm(self):
    &#34;&#34;&#34;
    extendArm will increase the length of section by a single unit
    if the length is below the maximum increase. Curvature will remain
    constant
    :return: None
    &#34;&#34;&#34;

    if self.sectionLen == self.maxSectionLen:
        assert &#34;Section max length has reached&#34;
        return True
    else:
        self.sectionLen += 1
    if self.render:
        self.drawSection(self.currentAngle)
        self.displayCurve()
    return True</code></pre>
</details>
</dd>
<dt id="environment.section.getTipPos"><code class="name flex">
<span>def <span class="ident">getTipPos</span></span>(<span>self, transformations)</span>
</code></dt>
<dd>
<div class="desc"><p>getTipPos return a (x,y) coordinate of where the tip of the section is located
:return: float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTipPos(self, transformations):
    &#34;&#34;&#34;
    getTipPos return a (x,y) coordinate of where the tip of the section is located
    :return: float
    &#34;&#34;&#34;
    angle = self.currentAngle
    if angle == 0:  # Use epsilon difference
        angle = self.zero

    radius = self.sectionLen / angle  # curvature is 0 ==&gt; radius is infinite

    t = np.linspace(0, angle, self.sectionLen)
    x = radius * np.cos(t)
    y = radius * np.sin(t)

    allPoints = np.vstack((x, y)).T
    allPoints[:, 0] = allPoints[:, 0] - radius

    for i in range(len(transformations)):
        baseAngle = transformations[i]
        r = np.array(((np.cos(baseAngle), -np.sin(baseAngle)),
                      (np.sin(baseAngle), np.cos(baseAngle))))
        allPoints = np.dot(r, allPoints.T).T

    allPoints[:, 0] = allPoints[:, 0] + self.baseLocation[0]
    allPoints[:, 1] = allPoints[:, 1] + self.baseLocation[1]

    px = allPoints[-1][0]
    py = allPoints[-1][1]

    point = [px, py]

    return point</code></pre>
</details>
</dd>
<dt id="environment.section.setBaseLocation"><code class="name flex">
<span>def <span class="ident">setBaseLocation</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>setBaseLocation is used modify the starting position of
the section.
:param x: x coordinate of the new base position
:param y: y coordinate of the new base position
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBaseLocation(self, x, y):
    &#39;&#39;&#39;
    setBaseLocation is used modify the starting position of
    the section.
    :param x: x coordinate of the new base position
    :param y: y coordinate of the new base position
    :return: None
    &#39;&#39;&#39;
    self.baseLocation = [x, y]</code></pre>
</details>
</dd>
<dt id="environment.section.setRender"><code class="name flex">
<span>def <span class="ident">setRender</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>setRender Method is used enable/disable rendering
:param state: bool
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setRender(self, state):
    &#39;&#39;&#39;
    setRender Method is used enable/disable rendering
    :param state: bool
    :return: None
    &#39;&#39;&#39;
    self.render = state</code></pre>
</details>
</dd>
<dt id="environment.section.stepLeft"><code class="name flex">
<span>def <span class="ident">stepLeft</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>stepLeft function will increase the curvature angle towards 2π
while the section Length will remain the same. Each step will
increase the angle by 0.01
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stepLeft(self):
    &#34;&#34;&#34;
    stepLeft function will increase the curvature angle towards 2π
    while the section Length will remain the same. Each step will
    increase the angle by 0.01
    :return: None
    &#34;&#34;&#34;
    # increase by angle by .5 degree
    if self.currentAngle == self.zero:
        self.currentAngle = 0

    self.currentAngle += 0.01
    if self.currentAngle &gt;= self.leftLimit:
        self.currentAngle -= 0.01
        # print(&#34;Left angle limit reached&#34;, self.currentAngle)
        return False

    if self.render:
        self.drawSection(self.currentAngle)

    return True</code></pre>
</details>
</dd>
<dt id="environment.section.stepRight"><code class="name flex">
<span>def <span class="ident">stepRight</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>stepRight function will decrease the curvature angle towards -2π
while the section Length will remain the same. Each step will
decrease the angle by 0.01
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stepRight(self):
    &#34;&#34;&#34;
    stepRight function will decrease the curvature angle towards -2π
    while the section Length will remain the same. Each step will
    decrease the angle by 0.01
    :return: None
    &#34;&#34;&#34;
    # decrease by angle by .5 degree
    if self.currentAngle == self.zero:
        self.currentAngle = 0

    self.currentAngle -= 0.01
    if self.currentAngle &lt;= -self.leftLimit:
        self.currentAngle += 0.01
        # print(&#34;Right angle limit reached&#34;, self.currentAngle)
        return False
    if self.render:
        self.drawSection(self.currentAngle)

    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="environment.distance" href="#environment.distance">distance</a></code></li>
<li><code><a title="environment.randint" href="#environment.randint">randint</a></code></li>
<li><code><a title="environment.random_color" href="#environment.random_color">random_color</a></code></li>
<li><code><a title="environment.seed" href="#environment.seed">seed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="environment.Environment" href="#environment.Environment">Environment</a></code></h4>
<ul class="">
<li><code><a title="environment.Environment.buildRenderComponents" href="#environment.Environment.buildRenderComponents">buildRenderComponents</a></code></li>
<li><code><a title="environment.Environment.done" href="#environment.Environment.done">done</a></code></li>
<li><code><a title="environment.Environment.drawGround" href="#environment.Environment.drawGround">drawGround</a></code></li>
<li><code><a title="environment.Environment.drawPoint" href="#environment.Environment.drawPoint">drawPoint</a></code></li>
<li><code><a title="environment.Environment.drawReward" href="#environment.Environment.drawReward">drawReward</a></code></li>
<li><code><a title="environment.Environment.drawTaskSpace" href="#environment.Environment.drawTaskSpace">drawTaskSpace</a></code></li>
<li><code><a title="environment.Environment.generatePoint" href="#environment.Environment.generatePoint">generatePoint</a></code></li>
<li><code><a title="environment.Environment.getObservation" href="#environment.Environment.getObservation">getObservation</a></code></li>
<li><code><a title="environment.Environment.pointCapture" href="#environment.Environment.pointCapture">pointCapture</a></code></li>
<li><code><a title="environment.Environment.render" href="#environment.Environment.render">render</a></code></li>
<li><code><a title="environment.Environment.reset" href="#environment.Environment.reset">reset</a></code></li>
<li><code><a title="environment.Environment.robotStep" href="#environment.Environment.robotStep">robotStep</a></code></li>
<li><code><a title="environment.Environment.staticPoint" href="#environment.Environment.staticPoint">staticPoint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="environment.Observation" href="#environment.Observation">Observation</a></code></h4>
</li>
<li>
<h4><code><a title="environment.Robot" href="#environment.Robot">Robot</a></code></h4>
<ul class="">
<li><code><a title="environment.Robot.buildRenderComponents" href="#environment.Robot.buildRenderComponents">buildRenderComponents</a></code></li>
<li><code><a title="environment.Robot.endEffectorPos" href="#environment.Robot.endEffectorPos">endEffectorPos</a></code></li>
<li><code><a title="environment.Robot.genActionSet" href="#environment.Robot.genActionSet">genActionSet</a></code></li>
<li><code><a title="environment.Robot.getAllCurrentAngles" href="#environment.Robot.getAllCurrentAngles">getAllCurrentAngles</a></code></li>
<li><code><a title="environment.Robot.getAllSectionConfigurations" href="#environment.Robot.getAllSectionConfigurations">getAllSectionConfigurations</a></code></li>
<li><code><a title="environment.Robot.newSection" href="#environment.Robot.newSection">newSection</a></code></li>
<li><code><a title="environment.Robot.randomAction" href="#environment.Robot.randomAction">randomAction</a></code></li>
<li><code><a title="environment.Robot.render" href="#environment.Robot.render">render</a></code></li>
<li><code><a title="environment.Robot.reset" href="#environment.Robot.reset">reset</a></code></li>
<li><code><a title="environment.Robot.step" href="#environment.Robot.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="environment.section" href="#environment.section">section</a></code></h4>
<ul class="two-column">
<li><code><a title="environment.section.contractArm" href="#environment.section.contractArm">contractArm</a></code></li>
<li><code><a title="environment.section.displayCurve" href="#environment.section.displayCurve">displayCurve</a></code></li>
<li><code><a title="environment.section.drawSection" href="#environment.section.drawSection">drawSection</a></code></li>
<li><code><a title="environment.section.extendArm" href="#environment.section.extendArm">extendArm</a></code></li>
<li><code><a title="environment.section.getTipPos" href="#environment.section.getTipPos">getTipPos</a></code></li>
<li><code><a title="environment.section.setBaseLocation" href="#environment.section.setBaseLocation">setBaseLocation</a></code></li>
<li><code><a title="environment.section.setRender" href="#environment.section.setRender">setRender</a></code></li>
<li><code><a title="environment.section.stepLeft" href="#environment.section.stepLeft">stepLeft</a></code></li>
<li><code><a title="environment.section.stepRight" href="#environment.section.stepRight">stepRight</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>